// -*- go -*-
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/bobg/fab"
	"github.com/bobg/fab/sqlite"
	"github.com/pkg/errors"

	subpkg "x/pkg/{{ .Subpkg }}"
)

var (
	wantDirhash = "{{ .Dirhash }}"
	pkgdir      = "{{ .Pkgdir }}"
	binfile     = "{{ .Binfile }}"
)

func main() {
	index := map[string]fab.Target{
		{{ range .Targets }}
		"{{ .SnakeName }}": subpkg.{{ .Name }},
		{{ end }}
	}

	var (
		names = make(map[uintptr]string)
		v     reflect.Value
	)
	{{ range .Targets }}
	v = reflect.ValueOf(subpkg.{{ .Name }})
	if v.Kind() == reflect.Pointer {
		names[v.Pointer()] = "{{ .Name }}"
	}
	{{ end }}

	ctx := context.Background()
	ctx = fab.WithNames(ctx, names)

	var (
		verbose bool
		nocheck bool
		dbfile  string
	)
	flag.BoolVar(&verbose, "v", false, "run verbosely")
	flag.BoolVar(&nocheck, "nocheck", false, "suppress dirhash checking")
	flag.StringVar(&dbfile, "db", "", "path to Sqlite3 hash database file")
	flag.Parse()

	if !nocheck {
		entries, err := os.ReadDir(pkgdir)
		if err != nil {
			fatalf("Reading directory %s: %s", pkgdir, err)
		}
		dh := fab.NewDirHasher()
		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), "_test.go") {
				continue
			}
			if !strings.HasSuffix(entry.Name(), ".go") {
				continue
			}
			if err = addFileToHash(dh, filepath.Join(pkgdir, entry.Name())); err != nil {
				fatalf("Hashing file %s/%s: %s", pkgdir, entry.Name(), err)
			}
		}
		gotDirhash, err := dh.Hash()
		if err != nil {
			fatalf("Reading dirhash: %s", err)
		}
		if gotDirhash != wantDirhash {
			fmt.Printf("Recompiling %s\n", binfile)
			err = fab.Compile(ctx, pkgdir, binfile)
			if err != nil {
				fatalf("Compiling %s: %s", binfile, err)
			}
			abs, err := filepath.Abs(binfile)
			if err != nil {
				fatalf("Computing absolute pathname for %s", binfile)
			}
			args := []string{"-nocheck"}
			args = append(args, os.Args[1:]...)
			cmd := exec.CommandContext(ctx, abs, args...)
			cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
			if err = cmd.Run(); err != nil {
				fatalf("Running %s %s: %s", abs, strings.Join(args, " "), err)
			}
			return
		}
	}

	ctx = fab.WithVerbose(ctx, verbose)

	if dbfile != "" {
		db, err := sqlite.Open(ctx, dbfile, sqlite.Keep(30*24*time.Hour)) // keep db entries for 30 days
		if err != nil {
			fatalf("Error opening %s: %s", dbfile, err)
		}
		defer db.Close()
		ctx = fab.WithHashDB(ctx, db)
	}

	args := flag.Args()
	if len(args) == 0 {
		if _, ok := index["default"]; !ok {
			fatalf("No targets given and no default target defined")
		}
		args = []string{"default"}
	}

	var (
		targets []fab.Target
		unknown []string
	)

	for _, arg := range args {
		if target, ok := index[arg]; ok {
			targets = append(targets, target)
		} else {
			unknown = append(unknown, arg)
		}
	}

	if len(unknown) > 0 {
		fatalf("Unknown target(s): %s", strings.Join(unknown, " "))
	}

	runner := fab.NewRunner()
	if err := runner.Run(ctx, targets...); err != nil {
		fatalf("Error: %s", err)
	}
}

func fatalf(format string, args ...any) {
	fmt.Printf(format, args...)
	if !strings.HasSuffix(format, "\n") {
		fmt.Println("")
	}
	os.Exit(1)
}

func addFileToHash(dh *fab.DirHasher, filename string) error {
	f, err := os.Open(filename)
	if err != nil {
		return errors.Wrapf(err, "opening %s", filename)
	}
	defer f.Close()

	return dh.File(filename, f)
}
